# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
![2.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020709.png)

### 思路
* 标签：` 动态规划 `：通过子问题答案来解决大问题答案；子问题都需要是离散且不依赖其他子问题（详可见 [《算法图解》](https://depp.wang/Java-Books/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.epub) 第九章「动态规划」）；
* 回文字符串是正读和反读都一样，所以如果将回文字符串反转，那么字符串和反转字符串肯定完全一样。
* 如果字符串不是回文字符串，那么字符串和反转字符串如果有相同的部分，即公共子串，那么最长的公共子串是不是一定就是最长回文子串嗯？关于如何得到最长公共子串，看下面 [这里](#如何得到最长公共子串)
* 我们发现，最长公共子串不一定就是最长回文子串，比如字符串 S 为 `aacdecaa`，反转字符串为 `aacedcaa`，最长公共子串有 aac 和 caa，都不是回文子串，更不是最长回文子串。所以需要进一步判断最长公共子串是否是回文子串。
* 时间复杂度：O(n^2) -- 两层遍历。
* 空间复杂度：O(n^2) -- 二维数组。


### 代码
```Java
// Java
class Solution {
    public String longestPalindrome(String s) {
        if (s.equals("")) {
            return "";
        }
        int length = s.length();
        String reversal = new StringBuffer(s).reverse().toString(); // 反转字符串
        int[][] cell = new int[length][length];
        int maxLen = 0; // 最长回文子串长度
        int maxEnd = 0; // 最长回文子串结束位置
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                if (reversal.charAt(i) == s.charAt(j)) {
                    if (i == 0 || j == 0) {
                        cell[i][j] = 1;
                    } else {
                        cell[i][j] = cell[i - 1][j - 1] + 1;
                    }
                }
                /**************相比最长公共子串，修改的地方***************************/
                // 可为空，不用置为 0，减少运行时间
//                else {
//                    cell[i][j] = 0;
//                }
                /**************************************************/
                if (cell[i][j] > maxLen) {
                    /**************相比最长公共子串，修改的地方***************************/
                    int beforeIndex = length - 1 - i; // 反向子串末尾字符的原始索引
                    int firstIndex =  j - cell[i][j] + 1; // 子串的首字符索引
                    if (beforeIndex == firstIndex) { // 通过检查反向子串的原始索引是否与子串索引相同，来排除反向副本的情况。不需要检查反向子串的每个字符，只需要检查反向子串末尾字符的原始索引，是否等于子串的首字符索引即可。
                        maxLen = cell[i][j];
                        maxEnd = j;
                    }
                    /**************************************************/
                }
            }
        }
        return s.substring(maxEnd + 1 - maxLen, maxEnd + 1);
    }
}
```
```JavaScript
// JavaScript
var longestPalindrome = function (s) {
    if (s === "") {
        return "";
    }
    let cell = [], maxLen = 0, maxEnd = 0;
    for (let i = 0; i < s.length; i++) {
        cell.push([]);
        for (let j = 0; j < s.length; j++) {
            let beforeIndex = s.length - 1 - i;
            if (s[beforeIndex] === s[j]) {
                if (i === 0 || j === 0) {
                    cell[i][j] = 1;
                } else {
                    cell[i][j] = cell[i - 1][j - 1] + 1;
                }
            } else {
                cell[i][j] = 0; // 不能省略，用于「占坑」
            }
            if (cell[i][j] > maxLen) {
                let firstIndex = j - cell[i][j] + 1;
                if (beforeIndex === firstIndex) {
                    maxLen = cell[i][j];
                    maxEnd = j;
                }
            }
        }
    }
    return s.slice(maxEnd + 1 - maxLen, maxEnd + 1)
};
```
### 画解
![1-2.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020711.png)
![2-2(2).png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020712.png)
![1.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020714.png)
![2.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020709.png)

## 如何得到最长公共子串

### 思路

- 将字符串 `S` 反转为 `S'`可以直观看出，`S = abac` 和 `S' = caba` 的最长公共子串为 `aba`
- 需要利用动态规划来得到 **最长公共子串**，这里的动态规划通过网格的斜线来实现。
- `S` 和 `S'` 分别置于横、纵坐标，通过网格（二维数组）一一比较子串（每一个子串就是一个子问题），**当前公共子串的长度等于前面公共子串的长度加一，网格记录当前公共子串的长度**。
- 通过最长公共子串的长度和结束位置，得到最长公共子串。

### 代码

```Java
// Java
class Solution {
    public String longestPalindrome(String s) {
        if (s.equals("")) {
            return "";
        }
        int length = s.length();
        String reversal = new StringBuffer(s).reverse().toString(); // 反转字符串
        int[][] cell = new int[length][length];
        int maxLen = 0; // 最长公共子串长度
        int maxEnd = 0; // 最长公共子串结束位置
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                if (reversal.charAt(i) == s.charAt(j)) {
                    if (i == 0 || j == 0) {
                        cell[i][j] = 1;
                    } else {
                        cell[i][j] = cell[i - 1][j - 1] + 1; // 公共子串长度
                    }
                } else {
                    cell[i][j] = 0;
                }
                if (cell[i][j] > maxLen) {
                    maxLen = cell[i][j];
                    maxEnd = j;
                }
            }
        }
        return s.substring(maxEnd + 1 - maxLen, maxEnd + 1);
    }
}
```
```JavaScript
// JavaScript
var longestPalindrome = function (s) {
    if (s === "") {
        return "";
    }
    let cell = [], maxLen = 0, maxEnd = 0;
    for (let i = 0; i < s.length; i++) {
        cell.push([]);
        for (let j = 0; j < s.length; j++) {
            let reverseChar = s[s.length - 1 - i];
            if (reverseChar === s[j]) {
                if (i === 0 || j === 0) {
                    cell[i][j] = 1;
                } else {
                    cell[i][j] = cell[i - 1][j - 1] + 1;
                }
            } else {
                cell[i][j] = 0;
            }
            if (cell[i][j] > maxLen) {
                maxLen = cell[i][j];
                maxEnd = j;
            }
        }
    }
    return s.slice(maxEnd + 1 - maxLen, maxEnd + 1)
};
```
### 画解
![1-1.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020717.png)
![2-1.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020718.png)
![3-1.png](https://deppwang.oss-cn-beijing.aliyuncs.com/blog/2019-12-22-020720.png)



## 测试用例

描述 | 1 | 2 | 3 | 4 | 5 
---|---|---|---|---|---
输入 | "" | "a" | "abac" | "abcda"| "aacdecaa" 
输出 | "" | "a" |  "aba" |"a" | "aa"