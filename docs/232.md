# 232. 用栈实现队列
https://leetcode-cn.com/problems/implement-queue-using-stacks/

![](https://tva1.sinaimg.cn/large/006tNbRwly1ga0wfu3bi2j30hs06hmy9.jpg)

### 思路

* 标签：`栈`、`队列`
* 栈：先进后出（FILO）、队列：先进先出（FIFO）
* 使用两个栈，一个栈 s1 作为数据存储，一个栈 s2 作为临时缓冲
* 最简单的方式：入队列：元素压入 s1；出队列：将 s1所有元素倒入到 s2，s2 弹出栈顶元素，再将 s2 倒回 s1
* 优化（不倒回）：入队列：元素压入 s1；出队列：判断 s2 是否为空，如果为空，将 s1所有元素倒入到 s2，s2 弹出栈顶元素，不将 s2 倒回 s1，避免每次出队列重复倒回
* 时间复杂度：入队 O(1)，出队 O(1) 

### 代码

```Java
class MyQueue {
    Stack s1;
    Stack s2;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        this.s1 = new Stack();
        this.s2 = new Stack();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        s1.push(x);
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
//        while (!s1.empty()) {
//            s2.push(s1.pop());
//        }
//        int pop = (int) s2.pop();
//        while (!s2.empty()) {
//            s1.push(s2.pop());
//        }
//        return pop;
        // 优化后
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.pop());
            }
        }
        return (int) s2.pop();

    }

    /**
     * Get the front element.
     */
    public int peek() {
//        while (!s1.empty()) {
//            s2.push(s1.pop());
//        }
//        int peek = (int) s2.peek();
//        while (!s2.empty()) {
//            s1.push(s2.pop());
//        }
//        return peek;
        // 优化后
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.pop());
            }
        }
        return (int) s2.peek();
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return s1.empty() && s2.isEmpty();
    }
}
```
